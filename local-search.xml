<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>学习使用Flink</title>
    <link href="/2021/11/28/flink-weibo/"/>
    <url>/2021/11/28/flink-weibo/</url>
    
    <content type="html"><![CDATA[<p>本实验针对MicroblogPCU数据集进行分析，采用Python为编程语言，采用mysql存储数据，采用flink对数据进行处理分析，并对结果进行数据可视化。</p><p>Flink 是目前非常火热的流处理框架，可以很好地实现批流一体，即一套代码既可以用于批处理，也可以用于流处理。 Flink 在做批处理的时候，是将批数据当成特殊的流数据来处理。PyFlink 是 Flink 对 Java API 的一层封装，运行时会启动 JVM 来与 Python 进行通信。<br> PyFlink 提供了多种不同层级的 API，层级越高封装程度越高，层级由高到低分别为:SQL API、Table API、DataStream API / DataSet API、Stateful Streaming Processing，此次实验在Table API 的基础上进行编程。</p><h2 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h2><ul><li>系统: macos Big Sur 11.2.2</li><li> Java : 11.0.10</li><li>Python : 3.9.2 | packaged by conda-forge</li><li>Flink : 1.12.2</li></ul><p>通过homebrew在本机安装apache-flink之后，运行文件夹下的start-cluster.sh启动flink集群模式（之后通过修改用户配置文件，用命令<code>start-flink</code>来替代这一步）</p><p>用<code>flink run -m localhost:8081 -py weibo.py</code>运行python程序，并通过<code>localhost:8081</code>在web页面打开flink的dashboard，查看作业的运行情况。</p><p><img src="/img/image-20210607203836096.png"></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><p>MicroblogPCU是从新浪微博采集到的一个用于探索微博中的spammers（发送垃圾信息的人）的数据集，它可以被用于研究机器学习方法和社会关系研究。本文将利用这个数据集探究spammer的一些行为特征，并分析它们和正常社交账号的行为区别。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>本次实验采用pandas库对数据进行预处理，读取csv文件后到Dataframe后，清洗各个属性和处理缺失值，取出微博用户的微博文本内容、发博时间，粉丝数、关注人数、发博数、等级这些属性进行处理分析。 </p><h4 id="文件编码转化"><a href="#文件编码转化" class="headerlink" title="文件编码转化"></a>文件编码转化</h4><p>直接读取发现乱码，用macOS自带的iconv命令行工具将gb2312编码的数据源文件转为utf-8编码 <code> iconv -c -f gb2312 -t UTF-8 file &gt;&gt; new_file</code></p><h4 id="查看csv数据"><a href="#查看csv数据" class="headerlink" title="查看csv数据"></a>查看csv数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">file_path=<span class="hljs-string">&#x27;weibo_user.csv&#x27;</span><br>df = pd.read_csv(file_path,encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>df.head()<br></code></pre></td></tr></table></figure><h4 id="清洗用户message的文本内容"><a href="#清洗用户message的文本内容" class="headerlink" title="清洗用户message的文本内容"></a>清洗用户message的文本内容</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clean_msg</span>(<span class="hljs-params">text</span>):</span><br>    text = re.sub(<span class="hljs-string">r&quot;(回复)?(//)?\s*@\S*?\s*(:| |$)&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, text)  <span class="hljs-comment"># 去除正文中的@和回复/转发中的用户名</span><br>    text = re.sub(<span class="hljs-string">r&quot;\[\S+\]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, text)      <span class="hljs-comment"># 去除表情符号</span><br>    <span class="hljs-comment">#text = re.sub(r&quot;#\S+#&quot;, &quot;&quot;, text)       # 保留话题内容</span><br>    URL_REGEX = re.<span class="hljs-built_in">compile</span>(<br>        <span class="hljs-string">r&#x27;(?i)\b((?:https?://|www\d&#123;0,3&#125;[.]|[a-z.\-]+[.][a-z]&#123;2,4&#125;/)(?:[^\s()&lt;&gt;]+|\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\))+(?:\(([^\s()&lt;&gt;]+|(\([^\s()&lt;&gt;]+\)))*\)|[^\s`!()\[\]&#123;&#125;;:\&#x27;&quot;.,&lt;&gt;?«»“”‘’]))&#x27;</span>,<br>        re.IGNORECASE)  <span class="hljs-comment"># 不保留数字</span><br>    text = re.sub(URL_REGEX, <span class="hljs-string">&quot;&quot;</span>, text)       <span class="hljs-comment"># 去除网址</span><br>    text = re.sub(<span class="hljs-string">r&quot;\s+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, text)  <span class="hljs-comment"># 合并正文中过多的空格</span><br>    <span class="hljs-keyword">return</span> text.strip()<br></code></pre></td></tr></table></figure><h4 id="时间格式清洗"><a href="#时间格式清洗" class="headerlink" title="时间格式清洗"></a>时间格式清洗</h4><p>为了对spammer发博日期和时间分别做研究，把字符串中的日期和时间单独提取出来，并生成datetime类型；</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str_to_date_wb</span>(<span class="hljs-params">date_str</span>):</span><br>    date = date_str.split(<span class="hljs-string">&#x27; &#x27;</span>)[<span class="hljs-number">0</span>]<br>    fmt = <span class="hljs-string">&#x27;%Y/%m/%d&#x27;</span><br>    time_tuple = time.strptime(date, fmt)<br>    year, month, day = time_tuple[:<span class="hljs-number">3</span>]<br>    <span class="hljs-keyword">return</span> datetime.date(year, month, day)<br><br>df[<span class="hljs-string">&#x27;date&#x27;</span>]=df[<span class="hljs-string">&#x27;post_time&#x27;</span>].<span class="hljs-built_in">map</span>(str_to_date_wb)<br></code></pre></td></tr></table></figure><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><ol><li>查看数据是否具有重复值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df.followee_num.isnull(),<span class="hljs-string">&#x27;followee_num&#x27;</span>]<br></code></pre></td></tr></table></figure><ol start="2"><li>查看各字段缺失率，缺失的位置用自定义的值填充</li></ol><ul><li>例如，时间缺失值的处理：全部设置为1990/1/1 00:00</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df.loc[df[<span class="hljs-string">&#x27;post_time&#x27;</span>].isnull(),<span class="hljs-string">&#x27;post_time&#x27;</span>]=<span class="hljs-string">&#x27;1990/1/1 00:00&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>标签1表示是spammer，-1表示不是spammer，NAN数据用0填充。</li></ul><ol start="3"><li><p>选取要研究的属性，删除不研究的属性，保存到当前路径下的csv文件中，命名为“washnew.csv”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">cols = [<span class="hljs-string">&#x27;user_id&#x27;</span>,<span class="hljs-string">&#x27;gender&#x27;</span>,<span class="hljs-string">&#x27;post_num&#x27;</span>,<span class="hljs-string">&#x27;message&#x27;</span>,<span class="hljs-string">&#x27;follower_num&#x27;</span>,<span class="hljs-string">&#x27;followee_num&#x27;</span>,<span class="hljs-string">&#x27;is_spammer&#x27;</span>]<br>df[cols].to_csv(<span class="hljs-string">&#x27;washednew.csv&#x27;</span>,header=<span class="hljs-literal">None</span>) <br></code></pre></td></tr></table></figure></li></ol><h2 id="PyFlink批处理"><a href="#PyFlink批处理" class="headerlink" title="PyFlink批处理"></a>PyFlink批处理</h2><ul><li><p>首先，创建 Blink 批处理环境</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pyflink.table <span class="hljs-keyword">import</span> BatchTableEnvironment, EnvironmentSettings<br><span class="hljs-keyword">from</span> pyflink.table <span class="hljs-keyword">import</span> DataTypes<br><span class="hljs-keyword">from</span> pyflink.table.descriptors <span class="hljs-keyword">import</span> Schema, OldCsv, FileSystem<br><br>env_settings = EnvironmentSettings.new_instance().in_batch_mode().use_blink_planner().build()<br>t_env = BatchTableEnvironment.create(environment_settings=env_settings)<br></code></pre></td></tr></table></figure></li><li><p>创建源表(source)，source 指数据源，这里使用同级目录下 weibo_user.csv清洗后的washednew.csv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">dir_word = os.path.join(os.path.abspath(os.path.dirname(__file__)), <span class="hljs-string">&#x27;washednew.csv&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>通过Table API 创建一张表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">t_env.connect(FileSystem().path(dir_word)) \<br>    .with_format(OldCsv() \<br>                 .field(<span class="hljs-string">&#x27;id&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;user_id&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;gender&#x27;</span>, DataTypes.STRING()) \<br>                 .field(<span class="hljs-string">&#x27;post_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;follower_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;followee_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;is_spammer&#x27;</span>, DataTypes.FLOAT())) \<br>    .with_schema(Schema() \<br>                 .field(<span class="hljs-string">&#x27;id&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;user_id&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;gender&#x27;</span>, DataTypes.STRING()) \<br>                 .field(<span class="hljs-string">&#x27;post_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;follower_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;followee_num&#x27;</span>, DataTypes.BIGINT()) \<br>                 .field(<span class="hljs-string">&#x27;is_spammer&#x27;</span>, DataTypes.FLOAT())) \<br>    .create_temporary_table(<span class="hljs-string">&#x27;source&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><h4 id="正常用户和spammer的粉丝量级比较"><a href="#正常用户和spammer的粉丝量级比较" class="headerlink" title="正常用户和spammer的粉丝量级比较"></a>正常用户和spammer的粉丝量级比较</h4><p>用Table API从表中取出数据。</p><p>以选择feature为“followee_num”为例，为了将粉丝数划分为’百’,’千’,’万’,’十万’,’百万’,’千万’的数量级，每次用条件选择和”count”从表中取出符合范围的数据，并利用group_by方法区分spammer和正常用户的两者数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">z1 = tb.where(col(feature)&lt;<span class="hljs-number">1000</span> ) \<br>         .group_by(col(<span class="hljs-string">&#x27;is_spammer&#x27;</span>)) \<br>         .select(<span class="hljs-string">&#x27;count(1) AS cnt&#x27;</span>).to_pandas() <br></code></pre></td></tr></table></figure><p>可视化比较正常用户和spammer的粉丝量级，并输出图像到png文件。</p><p>从图中可以看出，正常用户的粉丝数量从百级到千万级不等，并且千级以上的部分分布相对均匀，而spammer用户的粉丝量均在1000以下，说明spammer用户是很难积累粉丝量的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">z = pd.concat([z1,z2,z3,z4,z5,z6],axis=<span class="hljs-number">1</span>,ignore_index=<span class="hljs-keyword">True</span>)<br>z.<span class="hljs-keyword">columns</span>=[<span class="hljs-string">&#x27;百&#x27;</span>,<span class="hljs-string">&#x27;千&#x27;</span>,<span class="hljs-string">&#x27;万&#x27;</span>,<span class="hljs-string">&#x27;十万&#x27;</span>,<span class="hljs-string">&#x27;百万&#x27;</span>,<span class="hljs-string">&#x27;千万&#x27;</span>]<br>z.<span class="hljs-keyword">index</span>=[<span class="hljs-string">&#x27;normal&#x27;</span>,<span class="hljs-string">&#x27;spammer&#x27;</span>]<br><br>z.plot(kind=<span class="hljs-string">&#x27;bar&#x27;</span>, <span class="hljs-keyword">stacked</span>=<span class="hljs-keyword">True</span>, alpha= <span class="hljs-number">0.7</span>)<br>plt.legend()<br>plt.title(<span class="hljs-string">&#x27;正常用户和spammer的粉丝量级比较&#x27;</span>)<br>plt.savefig(feature+<span class="hljs-string">&#x27;.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/img/image-20210610205912269.png"></p><h4 id="正常用户和spammer用户的关注人数比较"><a href="#正常用户和spammer用户的关注人数比较" class="headerlink" title="正常用户和spammer用户的关注人数比较"></a>正常用户和spammer用户的关注人数比较</h4><p>关注人数指该发文账户关注其他人的数量。首先查看数据大致情况，发现样本中的关注人数以“0～100”、“100～1000”以及“&gt;1000”划分是比较好的。为了直观显示各人数段的比例，采用饼图来绘制我们的数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python">fig,axes=plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-comment">#创建画布</span><br><br>labels= z.columns<br>sizes_m=z.loc[[<span class="hljs-string">&#x27;normal&#x27;</span>]].values.squeeze() <span class="hljs-comment">#normal对应的数值</span><br>sizes_f=z.loc[[<span class="hljs-string">&#x27;spammer&#x27;</span>]].values.squeeze()  <span class="hljs-comment">#spammer对应的数值</span><br>colors=[<span class="hljs-string">&#x27;green&#x27;</span>,<span class="hljs-string">&#x27;yellow&#x27;</span>,<span class="hljs-string">&#x27;orange&#x27;</span>]<span class="hljs-comment">#每块对应的颜色</span><br>explode=(<span class="hljs-number">0.05</span>,<span class="hljs-number">0.05</span>,<span class="hljs-number">0.05</span>)<span class="hljs-comment">#将每一块分割出来，值越大分割出的间隙越大</span><br><br>axes[<span class="hljs-number">0</span>].pie(sizes_m,<br>        colors=colors,<br>        labels=labels,<br>        explode=explode,<br>        autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>,<span class="hljs-comment">#数值设置为保留固定小数位的百分数</span><br>        shadow=<span class="hljs-literal">False</span>,<span class="hljs-comment">#无阴影设置</span><br>        startangle=<span class="hljs-number">90</span>,<span class="hljs-comment">#逆时针起始角度设置</span><br>        pctdistance=<span class="hljs-number">0.5</span>,<span class="hljs-comment">#数值距圆心半径背书距离</span><br>        labeldistance =<span class="hljs-number">1.05</span><span class="hljs-comment">#图例距圆心半径倍距离</span><br>       )<br>axes[<span class="hljs-number">0</span>].axis(<span class="hljs-string">&#x27;equal&#x27;</span>)<span class="hljs-comment">#x,y轴刻度一致，保证饼图为圆形</span><br>axes[<span class="hljs-number">0</span>].legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br>axes[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;正常用户关注数饼图&#x27;</span>)<br><br>axes[<span class="hljs-number">1</span>].pie(sizes_f,<br>        colors=colors,<br>        labels=labels,<br>        explode=explode,<br>        autopct=<span class="hljs-string">&#x27;%.2f%%&#x27;</span>,<br>        shadow=<span class="hljs-literal">False</span>,<br>        startangle=<span class="hljs-number">90</span>,<br>        pctdistance=<span class="hljs-number">0.5</span>,<br>        labeldistance =<span class="hljs-number">1.05</span><br>       )<br>axes[<span class="hljs-number">1</span>].axis(<span class="hljs-string">&#x27;equal&#x27;</span>)<br>axes[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;spammer用户关注数饼图&#x27;</span>)<br>axes[<span class="hljs-number">1</span>].legend(loc=<span class="hljs-string">&#x27;best&#x27;</span>)<br><br>fig.savefig(<span class="hljs-string">&#x27;followee_num.jpg&#x27;</span>,dpi=<span class="hljs-number">200</span>)<br></code></pre></td></tr></table></figure><p>从图中可以看出正常用户的关注数大多集中在100～1000，也就是几百人的关注量，约1/4关注人数在100人以内，小部分超过了1000人；而spammer账户有几乎一半的比例关注人数在1000以上，100～1000的部分的数量也达到了47.79%，极少数关注人数在100人以内。说明spammer账户倾向于通过大量关注其他微博来完成传播垃圾信息的目的。</p><p><img src="/img/followee_num.jpg"></p><h3 id="生成词云图"><a href="#生成词云图" class="headerlink" title="生成词云图"></a>生成词云图</h3><blockquote><p> 词云图是一种用来展现高频关键词的可视化表达，通过文字、色彩、图形的搭配，产生有冲击力地视觉效果，而且能够传达有价值的信息。词云就是通过形成“关键词云层”或“关键词渲染”，对网络文本中出现频率较高的“关键词”的视觉上的突出。</p></blockquote><p>本实验用词云图来处理spammer个人主页的“message”，从而直观地展示spammer账户涉及到的高频关些词，这些关键词能够体现spammer账户关注的话题领域以及传播垃圾信息的目的。</p><h4 id="安装相应的库包和python模块"><a href="#安装相应的库包和python模块" class="headerlink" title="安装相应的库包和python模块"></a>安装相应的库包和python模块</h4><p>安装phantomjs和pyecharts，用到了python的jieba分词模块和wordcloud词云绘制模块。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">fc=<span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> spm_msg:<br>    clean_msg(text) <span class="hljs-comment">#清洗文本中的特殊字符、无意义字符和连续空格等</span><br>    txt +=text<br>words=jieba.lcut(fc)<span class="hljs-comment">#分词</span><br>article=<span class="hljs-string">&#x27; &#x27;</span>.join(words)<br><br>c = wordcloud.WordCloud( \<br>    width = <span class="hljs-number">1000</span>, height = <span class="hljs-number">700</span>, \ <br>    background_color = <span class="hljs-string">&quot;white&quot;</span>, \<br>    font_path = <span class="hljs-string">&quot;drive/MyDrive/STHeiti Medium.ttc&quot;</span>    <br>    )<br>c.generate(article)<br><br>c.to_file(<span class="hljs-string">&#x27;词云图.png&#x27;</span>)<br></code></pre></td></tr></table></figure><p>探索spammers发送的message大致内容，从图中可以看出，spammers个人主页消息的一些关键词包括“微信”、“旅游”、“代理”、“时尚“等等。</p><p><img src="/img/%E8%AF%8D%E4%BA%91%E5%9B%BE-6.png"></p>]]></content>
    
    
    <categories>
      
      <category>做点事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flink</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test music</title>
    <link href="/2021/11/10/test-music/"/>
    <url>/2021/11/10/test-music/</url>
    
    <content type="html"><![CDATA[<h2 id="网易云"><a href="#网易云" class="headerlink" title="网易云"></a>网易云</h2>    <div id="aplayer-VHWXzVfQ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="31370984" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#6F42C1"    ></div><h2 id="QQ"><a href="#QQ" class="headerlink" title="QQ"></a>QQ</h2>    <div id="aplayer-uXhWFpWS" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="002S80690qXeFR" data-server="tencent" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#D9534F"    ></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>怎样做一个自动打卡程序</title>
    <link href="/2021/11/05/daka/"/>
    <url>/2021/11/05/daka/</url>
    
    <content type="html"><![CDATA[<h2 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h2><p>完成学校的每日健康打卡任务</p><h2 id="打卡流程"><a href="#打卡流程" class="headerlink" title="打卡流程:"></a>打卡流程:</h2><p>每天早上八点打开浏览器、打开学工网、登陆账号、点进打卡页面、选择确认、保存表单、确认打卡成功。</p><hr><h2 id="1-配置云服务器"><a href="#1-配置云服务器" class="headerlink" title="1. 配置云服务器"></a>1. 配置云服务器</h2><p>CentOS 7.6 64bit</p><h2 id="2-编写python程序"><a href="#2-编写python程序" class="headerlink" title="2. 编写python程序"></a>2. 编写python程序</h2><h3 id="模块安装"><a href="#模块安装" class="headerlink" title="模块安装"></a>模块安装</h3><ul><li><p>安装playwright模块</p><p>Playwright 是微软开源的一个基于 Node.js 的工具库，可使用一个相同的API调用Chromium（Google-Chrome、Microsoft-Edge）、WebKit（Apple-Safari）和Mozilla-Firefox浏览器自动执行任务。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pip install playwright -i https:<span class="hljs-regexp">//</span>pypi.douban.com/simple <br></code></pre></td></tr></table></figure></li><li><p>安装chromium浏览器</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">python -m playwright <span class="hljs-keyword">install</span> chromium<br></code></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>主要就是调用playwright模块里的API，完成打开网页、点击页面元素和输入信息的整个过程。</p><ul><li><p>参考文档<br><a href="https://pypi.org/project/playwright/">pypi文档：Playwright for Python</a><br><a href="https://playwright.dev/docs/api/class-page">playwright API文档</a></p></li><li><p>打开浏览器并创建page对象</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">browser</span> = playwright.chromium.launch(headless=<span class="hljs-literal">True</span>)<br><span class="hljs-attr">context</span> = browser.new_context()<br><span class="hljs-attr">page</span> = context.new_page()<br></code></pre></td></tr></table></figure></li><li><p>用到的函数功能：</p><ul><li><p>去到某个网址：<code>page.goto()</code></p></li><li><p>点击某个元素：<code>page.click()</code>，括号里内容是如何定位到该元素，具体需要看网页源码，参考官方文档<a href="https://playwright.dev/docs/selectors">Playwright元素选择器Selector</a></p></li><li><p>填写文本框（用户名、密码等）：<code>page.fill()</code>，用法：<code>page.fill(selector, value)</code>；<a href="https://playwright.dev/docs/api/class-page#page-fill">官方文档page.fill( )</a></p></li><li><p>在弹出的新页面中继续操作：<code>page.expect_popup()</code>函数，会返回一个<a href="https://docs.python.org/3/reference/datamodel.html#context-managers" title="Event context manager">EventContextManager</a>对象，取它的value就是一个新的page对象（<code>new_page = page.expect_popup().value</code>），后续同上</p></li></ul></li></ul><h2 id="3-设置定时任务执行程序"><a href="#3-设置定时任务执行程序" class="headerlink" title="3. 设置定时任务执行程序"></a>3. 设置定时任务执行程序</h2><ul><li><p>linux系统: <code>crontab -e</code>打开和编辑crond定时任务列表</p><p>🔗<a href="https://linuxhandbook.com/crontab/">学习Linux中crontab的概念。了解如何设置cron作业，以便在预定义的时间自动运行脚本和命令</a></p></li><li><p>macos系统类似linux，windows系统有一个任务计划程序</p></li></ul><h2 id="出现的环境配置问题"><a href="#出现的环境配置问题" class="headerlink" title="出现的环境配置问题"></a>出现的环境配置问题</h2><h5 id="1-检查python文件是否有开启可执行权限"><a href="#1-检查python文件是否有开启可执行权限" class="headerlink" title="1. 检查python文件是否有开启可执行权限"></a>1. 检查python文件是否有开启可执行权限</h5><h5 id="2-python版本的问题"><a href="#2-python版本的问题" class="headerlink" title="2. python版本的问题"></a>2. <strong>python</strong>版本的问题</h5><ul><li><p><strong>检查系统是否存在满足条件的版本：</strong></p><p> playwright要求有python3.7以上版本，检查系统是否安装了这个版本以上的python，再用对应版本的pip安装playwright</p></li><li><p><strong>系统存在多个版本，检查crond执行任务时调用的是否是满足条件的版本：</strong></p><p>出错情况：<br>命令行测试成功，但crond执行失败：crond执行任务的身份是root，通常linux下root的默认python解释器是python2.7，而这个版本下没有安装playwright，导致报错找不到模块；</p><p>查看python版本和调用权限情况：<code>ls -l | grep python</code></p></li></ul><h5 id="3-解决办法参考"><a href="#3-解决办法参考" class="headerlink" title="3. 解决办法参考"></a>3. <strong>解决办法参考</strong></h5><ul><li><p>直接修改root默认版本（不建议）</p></li><li><p>给新版本的python解释器加一个软链接到/usr/bin目录下，例如由conda安装的python3.9：</p><p> <code>ln -s /root/miniconda3/bin/python /usr/bin/python39</code></p><p> 然后在crond定时任务里调用python39解释器：</p><p> <code>0 8 * * * python39 [打卡程序] </code></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>做点事情</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Linux</tag>
      
      <tag>Node.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>画画的核心技能</title>
    <link href="/2021/11/05/paint-core/"/>
    <url>/2021/11/05/paint-core/</url>
    
    <content type="html"><![CDATA[<h3 id="颜色（颜色理论和颜色混合）"><a href="#颜色（颜色理论和颜色混合）" class="headerlink" title="颜色（颜色理论和颜色混合）"></a>颜色（颜色理论和颜色混合）</h3><p>绘画中色彩的准确运用归结为三个基本问题： <em>1. 我要混合的颜色是什么？ 2. 我如何混合它？ 3. 我应该把它放在哪里？</em></p><h3 id="画面组成（如何安排和设计各个部分）"><a href="#画面组成（如何安排和设计各个部分）" class="headerlink" title="画面组成（如何安排和设计各个部分）"></a>画面组成（如何安排和设计各个部分）</h3><ul><li><p>  可以归结为两个问题： <em>1. 你想说什么？你打算怎么说？</em></p><blockquote><p>一个好的构图应该毫不费力地从一个区域流向另一个区域，<strong>但时不时你会被一个突然的陈述抓住眼球</strong>，它会引起你的注意并打破这个flow。</p></blockquote></li><li><p>  常见的构图法则和理论可以作为指导方针，但不要把它们视为指令而受规则约束。</p></li></ul><h3 id="笔触（笔触的性质和外观）"><a href="#笔触（笔触的性质和外观）" class="headerlink" title="笔触（笔触的性质和外观）"></a>笔触（笔触的性质和外观）</h3><ul><li>笔触可以彰显自己的特色</li><li>通过大量练习来思考体会如何使用自己的画笔；</li></ul><h3 id="绘图（线条、形状和透视的准确性）"><a href="#绘图（线条、形状和透视的准确性）" class="headerlink" title="绘图（线条、形状和透视的准确性）"></a>绘图（线条、形状和透视的准确性）</h3><ul><li>  练习方法：平时画一些简短的常规草图可以使自己的手和眼睛保持敏锐。</li></ul><h3 id="边缘（硬边缘、软边缘和丢失边缘之间的关系）"><a href="#边缘（硬边缘、软边缘和丢失边缘之间的关系）" class="headerlink" title="边缘（硬边缘、软边缘和丢失边缘之间的关系）"></a>边缘（硬边缘、软边缘和丢失边缘之间的关系）</h3><ul><li><p> <strong>edge之间的关系</strong>很重要，边缘可以是硬的、软的或丢失的。</p></li><li><p>  当硬边缘被软边缘包围时，硬边缘往往会引起注意（tips：使用硬边缘将注意力吸引到你的焦点上）。</p></li><li><p> tips：可以首先从场景中最难的边缘下手</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>写点东西</category>
      
    </categories>
    
    
    <tags>
      
      <tag>painting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为Github.io博客安装好看的主题</title>
    <link href="/2021/07/06/hexo-blog/"/>
    <url>/2021/07/06/hexo-blog/</url>
    
    <content type="html"><![CDATA[<h1 id="安装环境配置"><a href="#安装环境配置" class="headerlink" title="安装环境配置"></a>安装环境配置</h1><p>（前提：macOS下配置了Git， 安装了Node.js）</p><p>安装 <code>hexo-deployer-git</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><h1 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h1><p><a href="https://fluid-dev.github.io/hexo-fluid-docs/start/#%E4%B8%BB%E9%A2%98%E7%AE%80%E4%BB%8B">https://fluid-dev.github.io/hexo-fluid-docs/start/#主题简介</a></p><h1 id="应用主题"><a href="#应用主题" class="headerlink" title="应用主题"></a>应用主题</h1><p>两种方案：</p><ul><li>直接用 theme/fluid/ 下面的 _config.fluid.yml （配置文件）里的内容替换根目录里的配置文件</li><li>在根目录里的配置文件中引用 fluid 配置文件:<br><code>theme: fluid</code></li></ul><h1 id="修改主页内容"><a href="#修改主页内容" class="headerlink" title="修改主页内容"></a>修改主页内容</h1><p>一些网页名称、主页banners标题、背景图片等等，都在配置文件里面修改</p><h1 id="生成和部署"><a href="#生成和部署" class="headerlink" title="生成和部署"></a>生成和部署</h1><ul><li><code>hexo g</code> 是编译生成，比如你往 _post/ 里加入一个 md 文件页面，执行该命令就会自动生成代码整合到 public/ 下面的 html 文件中去</li><li><code>hexo d</code> 是部署，相当于 git 的 add + commit + push，会把 hexo 文件夹里的 public 文件夹的内容（它里面包含了构成一个静态网页的全部内容和数据）上传到 github</li></ul><h1 id="安装音乐插件"><a href="#安装音乐插件" class="headerlink" title="安装音乐插件"></a>安装音乐插件</h1><p>参考<a href="https://easyhexo.com/3-Plugins-use-and-config/3-1-hexo-tag-aplayer/#%E4%BB%8B%E7%BB%8D">easy hexo关于hexo-tag-aplayer插件的安装指南</a></p><ul><li><p>Aplayer —— HTML5 music player，<a href="https://aplayer.js.org/#/zh-Hans/">中文文档</a><br>  使用 npm 安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install aplayer --save<br></code></pre></td></tr></table></figure></li><li><p>Meting（可以连接到国内网易云音乐、QQ 音乐等音乐媒体平台）<br>  只需要去音乐页面获取ID就可以调用歌曲：<br>![[Pasted image 20211110195040.png]]</p></li></ul><p>⚠️除了上面提出的内容之外，因为之前另外安装了主题Fluid，需要在主题配置文件 theme/fluid/_config.yml 中 custom 下引入插件依赖的js和css:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_js:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js</span> <span class="hljs-comment">#/APlayer#/APlayer依赖</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js</span> <span class="hljs-comment">#/APlayer依赖</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">custom_css:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">//cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css</span> <span class="hljs-comment">#/APlayer依赖</span><br></code></pre></td></tr></table></figure><h3 id="创建新文章"><a href="#创建新文章" class="headerlink" title="创建新文章"></a>创建新文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new [name]<br></code></pre></td></tr></table></figure><p>就会在 <code>_post/</code> 里加入一个 md 文件</p><h3 id="文章内容图片"><a href="#文章内容图片" class="headerlink" title="文章内容图片"></a>文章内容图片</h3><p>本地图片存放位置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markdown">![](/img/example.jpg)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>做点事情</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>人工智能理论——智能体</title>
    <link href="/2020/12/11/ai-agent/"/>
    <url>/2020/12/11/ai-agent/</url>
    
    <content type="html"><![CDATA[<blockquote><p>agent就是某种能够行动的东西（agent拉丁语意为“去做”）</p></blockquote><h2 id="理性智能体（AI的中心思想）"><a href="#理性智能体（AI的中心思想）" class="headerlink" title="理性智能体（AI的中心思想）"></a>理性智能体（AI的中心思想）</h2><p>通过自己的行动获得<em>最佳结果</em> /<em>最佳期望结果</em></p><ul><li><p>理性智能体的“理性”：  </p><ul><li>做出正确的推论，正确的行动（建立在逻辑主义“思维法则”上）    </li><li>不存在所谓正确的行动时，仍然要有所行动<blockquote><p>可以根据感知序列、对环境的先验知识，采取使期望<strong>性能度量</strong>最大化的行动，就叫理性智能体</p></blockquote></li></ul></li></ul><h2 id="智能体和环境"><a href="#智能体和环境" class="headerlink" title="智能体和环境"></a>智能体和环境</h2><p>环境也在影响智能体的表现</p><blockquote><p> 智能体：感知环境，并在环境中行动的东西</p></blockquote><blockquote><p> 智能体通过<strong>传感器</strong>感知环境，通过<strong>执行器</strong>对环境产生作用</p></blockquote><ul><li>环境描述：PEAS</li></ul><h3 id="在确定和不确定的环境中求解问题"><a href="#在确定和不确定的环境中求解问题" class="headerlink" title="在确定和不确定的环境中求解问题"></a>在确定和不确定的环境中求解问题</h3><ul><li><p>智能体在<strong>不确定</strong>的环境中行动：</p><h4 id="概率推理模型"><a href="#概率推理模型" class="headerlink" title="概率推理模型"></a><strong>概率推理模型</strong></h4><p>在不确定的环境下智能体行动的结果不是完全确定的，因而不能用“函数”来描述，而要用<strong>转移模型</strong>。</p><blockquote><p>对于每个可能的状态中的每种行动的结果的<strong>概率</strong>的详细说明，被称为转移模型。</p></blockquote><ul><li>贝叶斯法则、贝叶斯网络、马尔可夫过程……</li></ul></li><li><p>智能体在<strong>确定</strong>的环境中行动：</p><h4 id="搜索法"><a href="#搜索法" class="headerlink" title="搜索法"></a><strong>搜索法</strong></h4><ul><li>无信息的搜索策略：“在状态空间里盲目地按某种顺序寻找”，例如广度优先、深度优先、深度优先、双向搜索；</li><li>有信息的搜索策略：有评价函数和启发函数，根据函数评估结果寻找，例如最佳优先搜索、局部搜索；</li><li>此外还有“有约束“的问题、博弈问题（涉及到多个智能体）等。</li></ul></li></ul><h2 id="智能体分类"><a href="#智能体分类" class="headerlink" title="智能体分类"></a>智能体分类</h2><ul><li>简单反射型</li><li>基于模型的反射型（我的行动让世界如何演变，现在世界是什么样的）</li><li>基于目标的（通常结合世界模型，</li><li>基于效用的（相比于目标的二值区分，比较了不同的世界状态）</li></ul>]]></content>
    
    
    <categories>
      
      <category>写点东西</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AI</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
